services:
  # --------------------------
  # Redis Stream + MongoDB + Consumer (RedisStreamAndMongo 통합 실행)
  # --------------------------
  redis:
    # 변경 요청 반영:
    # - streaming-chat-server의 docker compose up 시 RedisStreamAndMongo의 stream Redis도 함께 실행한다.
    image: redis:7-alpine
    container_name: redis-stream
    command: redis-server --loglevel warning
    ports:
      - "6379:6379"
    volumes:
      - redis_stream_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      - redis-cluster-network

  mongodb:
    # 변경 요청 반영:
    # - Redis Stream consumer가 사용할 MongoDB를 동일 compose에서 함께 실행한다.
    image: mongo:7
    container_name: mongodb-local
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 5s
      timeout: 3s
      retries: 5
    networks:
      - redis-cluster-network

  comment-consumer:
    # 변경 요청 반영:
    # - RedisStreamAndMongo 폴더가 없어도 실행되도록 사전 빌드 이미지 기반으로 전환한다.
    # - 실제 이미지 태그는 streaming-chat-server/.env 파일의 COMMENT_CONSUMER_IMAGE로 외부 수정 가능하다.
    image: ${COMMENT_CONSUMER_IMAGE:-hyeon2/redis-stream-comment-consumer:latest}
    pull_policy: if_not_present
    container_name: comment-consumer
    env_file:
      # consume 주기(READ_BLOCK_MS) 포함 모든 consumer env를 외부 파일에서 수정 가능
      - ./consumer.env
    depends_on:
      redis:
        condition: service_healthy
      mongodb:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - redis-cluster-network

  chat-server:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: chat-server
    # 변경 요청 반영:
    # - Dockerfile ENTRYPOINT(java -jar /app/app.jar)에 전달될 실행 인자를 배열로 명시한다.
    # 이유:
    # - 기존 sh -c 문자열은 JVM 옵션으로 적용되지 않아 application.properties 기본값(localhost)이 사용되는 문제가 있었다.
    command:
      - --server.port=8080
      # 변경 요청 반영:
      # - Redis Cluster 노드 주소를 외부 .env 값으로 주입해 환경별로 수정 가능하게 함
      - --spring.redis.cluster.nodes=${CHAT_SERVER_REDIS_CLUSTER_NODES:-redis-node-1:7000,redis-node-2:7001,redis-node-3:7002,redis-node-4:7003,redis-node-5:7004,redis-node-6:7005}
      # 변경 요청 반영:
      # - 별도 host 네트워크 우회 대신 동일 compose 서비스명(redis)으로 Stream Redis에 연결한다.
      - --chat.stream.redis.host=${CHAT_SERVER_STREAM_REDIS_HOST:-redis}
      - --chat.stream.redis.port=${CHAT_SERVER_STREAM_REDIS_PORT:-6379}
      # 변경 요청 반영:
      # - chat-server 내부 localhost 접속 오류(Oracle/Mongo)를 방지하기 위해 컨테이너 서비스명으로 오버라이드
      - --spring.datasource.url=${CHAT_SERVER_ORACLE_URL:-jdbc:oracle:thin:@oracle-db:1521/XEPDB1}
      - --spring.datasource.username=${CHAT_SERVER_ORACLE_USERNAME:-SYSTEM}
      - --spring.datasource.password=${CHAT_SERVER_ORACLE_PASSWORD:-mypassword}
      - --spring.mongodb.uri=${CHAT_SERVER_MONGO_URI:-mongodb://mongodb:27017/commentdb}
      # WebSocket transport/channel tuning for high fan-out load
      - --chat.ws.transport.message-size-limit=${CHAT_SERVER_WS_MESSAGE_SIZE_LIMIT:-262144}
      - --chat.ws.transport.send-buffer-size-limit=${CHAT_SERVER_WS_SEND_BUFFER_SIZE_LIMIT:-4194304}
      - --chat.ws.transport.send-time-limit-ms=${CHAT_SERVER_WS_SEND_TIME_LIMIT_MS:-120000}
      - --chat.ws.channel.inbound.core-pool-size=${CHAT_SERVER_WS_INBOUND_CORE_POOL_SIZE:-16}
      - --chat.ws.channel.inbound.max-pool-size=${CHAT_SERVER_WS_INBOUND_MAX_POOL_SIZE:-128}
      - --chat.ws.channel.inbound.queue-capacity=${CHAT_SERVER_WS_INBOUND_QUEUE_CAPACITY:-50000}
      - --chat.ws.channel.outbound.core-pool-size=${CHAT_SERVER_WS_OUTBOUND_CORE_POOL_SIZE:-16}
      - --chat.ws.channel.outbound.max-pool-size=${CHAT_SERVER_WS_OUTBOUND_MAX_POOL_SIZE:-128}
      - --chat.ws.channel.outbound.queue-capacity=${CHAT_SERVER_WS_OUTBOUND_QUEUE_CAPACITY:-50000}
      - --chat.redis.listener.task-executor.core-pool-size=${CHAT_SERVER_REDIS_LISTENER_CORE_POOL_SIZE:-8}
      - --chat.redis.listener.task-executor.max-pool-size=${CHAT_SERVER_REDIS_LISTENER_MAX_POOL_SIZE:-64}
      - --chat.redis.listener.task-executor.queue-capacity=${CHAT_SERVER_REDIS_LISTENER_QUEUE_CAPACITY:-20000}
      - --chat.redis.listener.subscription-executor.core-pool-size=${CHAT_SERVER_REDIS_SUBSCRIPTION_CORE_POOL_SIZE:-4}
      - --chat.redis.listener.subscription-executor.max-pool-size=${CHAT_SERVER_REDIS_SUBSCRIPTION_MAX_POOL_SIZE:-16}
      - --chat.redis.listener.subscription-executor.queue-capacity=${CHAT_SERVER_REDIS_SUBSCRIPTION_QUEUE_CAPACITY:-1000}
      - --chat.fanout.talk.executor.core-pool-size=${CHAT_SERVER_FANOUT_TALK_CORE_POOL_SIZE:-8}
      - --chat.fanout.talk.executor.max-pool-size=${CHAT_SERVER_FANOUT_TALK_MAX_POOL_SIZE:-32}
      - --chat.fanout.talk.executor.queue-capacity=${CHAT_SERVER_FANOUT_TALK_QUEUE_CAPACITY:-10000}
      - --chat.fanout.system.executor.core-pool-size=${CHAT_SERVER_FANOUT_SYSTEM_CORE_POOL_SIZE:-2}
      - --chat.fanout.system.executor.max-pool-size=${CHAT_SERVER_FANOUT_SYSTEM_MAX_POOL_SIZE:-8}
      - --chat.fanout.system.executor.queue-capacity=${CHAT_SERVER_FANOUT_SYSTEM_QUEUE_CAPACITY:-2000}
      - --chat.fanout.backpressure.policy=${CHAT_SERVER_FANOUT_BACKPRESSURE_POLICY:-drop-newest}
      - --chat.fanout.backpressure.disconnect-count=${CHAT_SERVER_FANOUT_BACKPRESSURE_DISCONNECT_COUNT:-1}
      - --chat.fanout.backpressure.disconnect-reason=${CHAT_SERVER_FANOUT_BACKPRESSURE_DISCONNECT_REASON:-Slow consumer backpressure}
      - --chat.fanout.talk.batch.enabled=${CHAT_SERVER_FANOUT_TALK_BATCH_ENABLED:-false}
      - --chat.fanout.talk.batch.max-size=${CHAT_SERVER_FANOUT_TALK_BATCH_MAX_SIZE:-20}
      - --chat.fanout.talk.batch.max-wait-ms=${CHAT_SERVER_FANOUT_TALK_BATCH_MAX_WAIT_MS:-20}
    ports:
      - "8080:8080"
    # 변경 요청 반영:
    # - chat server 컨테이너 리소스 상한을 CPU 2Core / MEM 4GB로 지정한다.
    cpus: "2.0"
    mem_limit: "4g"
    mem_reservation: "2g"
    environment:
      # 변경 요청 반영:
      # - "메모리가 천천히만 내려가서 오래 걸린다"는 피드백 대응.
      # - 유휴 구간에서도 G1 주기 GC가 동작하도록 하고, 힙/오프힙 상한을 명시해
      #   테스트 후 RSS가 장시간 높게 유지되는 현상을 완화한다.
      JAVA_TOOL_OPTIONS: >-
        -XX:InitialRAMPercentage=10
        -XX:MaxRAMPercentage=35
        -XX:MaxHeapFreeRatio=20
        -XX:MinHeapFreeRatio=10
        -XX:G1PeriodicGCInterval=15000
        -XX:+ExplicitGCInvokesConcurrent
        -XX:MaxDirectMemorySize=256m
        -Xss512k
    restart: unless-stopped
    depends_on:
      redis:
        condition: service_started
      mongodb:
        condition: service_started
      oracle-db:
        condition: service_started
      comment-consumer:
        condition: service_started
      redis-node-1:
        condition: service_started
      redis-node-2:
        condition: service_started
      redis-node-3:
        condition: service_started
      redis-node-4:
        condition: service_started
      redis-node-5:
        condition: service_started
      redis-node-6:
        condition: service_started
      redis-cluster-init:
        condition: service_completed_successfully
    extra_hosts:
      - "host.docker.internal:host-gateway"
    networks:
      - redis-cluster-network

  # --------------------------
  # Redis Cluster Nodes
  # --------------------------
  redis-node-1:
    image: redis:7-alpine
    container_name: redis-node-1
    command: redis-server /usr/local/etc/redis/redis.conf
    volumes:
      - ./redis_cluster/node-1/data:/data
      - ./redis_cluster/node-1/redis.conf:/usr/local/etc/redis/redis.conf
    ports:
      - "7000:7000"
      - "17000:17000"
    networks:
      - redis-cluster-network

  redis-node-2:
    image: redis:7-alpine
    container_name: redis-node-2
    command: redis-server /usr/local/etc/redis/redis.conf
    volumes:
      - ./redis_cluster/node-2/data:/data
      - ./redis_cluster/node-2/redis.conf:/usr/local/etc/redis/redis.conf
    ports:
      - "7001:7001"
      - "17001:17001"
    networks:
      - redis-cluster-network

  redis-node-3:
    image: redis:7-alpine
    container_name: redis-node-3
    command: redis-server /usr/local/etc/redis/redis.conf
    volumes:
      - ./redis_cluster/node-3/data:/data
      - ./redis_cluster/node-3/redis.conf:/usr/local/etc/redis/redis.conf
    ports:
      - "7002:7002"
      - "17002:17002"
    networks:
      - redis-cluster-network

  redis-node-4:
    image: redis:7-alpine
    container_name: redis-node-4
    command: redis-server /usr/local/etc/redis/redis.conf
    volumes:
      - ./redis_cluster/node-4/data:/data
      - ./redis_cluster/node-4/redis.conf:/usr/local/etc/redis/redis.conf
    ports:
      - "7003:7003"
      - "17003:17003"
    networks:
      - redis-cluster-network

  redis-node-5:
    image: redis:7-alpine
    container_name: redis-node-5
    command: redis-server /usr/local/etc/redis/redis.conf
    volumes:
      - ./redis_cluster/node-5/data:/data
      - ./redis_cluster/node-5/redis.conf:/usr/local/etc/redis/redis.conf
    ports:
      - "7004:7004"
      - "17004:17004"
    networks:
      - redis-cluster-network

  redis-node-6:
    image: redis:7-alpine
    container_name: redis-node-6
    command: redis-server /usr/local/etc/redis/redis.conf
    volumes:
      - ./redis_cluster/node-6/data:/data
      - ./redis_cluster/node-6/redis.conf:/usr/local/etc/redis/redis.conf
    ports:
      - "7005:7005"
      - "17005:17005"
    networks:
      - redis-cluster-network

  redis-cluster-init:
    # 변경 요청 반영:
    # - docker compose up 시 Redis Cluster가 자동 초기화되도록 one-shot init 서비스를 추가
    image: redis:7-alpine
    container_name: redis-cluster-init
    depends_on:
      - redis-node-1
      - redis-node-2
      - redis-node-3
      - redis-node-4
      - redis-node-5
      - redis-node-6
    restart: "no"
    command:
      - sh
      - -c
      - |
        set -eu
        for node in redis-node-1:7000 redis-node-2:7001 redis-node-3:7002 redis-node-4:7003 redis-node-5:7004 redis-node-6:7005; do
          host="$${node%:*}"
          port="$${node#*:}"
          until redis-cli -h "$$host" -p "$$port" ping >/dev/null 2>&1; do
            echo "[redis-cluster-init] waiting $$host:$$port"
            sleep 1
          done
        done

        if redis-cli -h redis-node-1 -p 7000 cluster info | grep -q "cluster_state:ok"; then
          echo "[redis-cluster-init] cluster already initialized"
          exit 0
        fi

        echo "[redis-cluster-init] creating cluster"
        yes yes | redis-cli --cluster create \
          redis-node-1:7000 redis-node-2:7001 redis-node-3:7002 \
          redis-node-4:7003 redis-node-5:7004 redis-node-6:7005 \
          --cluster-replicas 1
    networks:
      - redis-cluster-network

  # --------------------------
  # Oracle Database Service
  # --------------------------
  oracle-db:
    platform: linux/amd64
    image: gvenzl/oracle-xe:21
    container_name: oracle-db-21
    environment:
      ORACLE_PASSWORD: mypassword # SYS, SYSTEM 비밀번호
      ORACLE_CHARACTERSET: AL32UTF8
    ports:
      - "1521:1521" # Listener
      - "5500:5500" # EM Express
    volumes:
      - oradata:/opt/oracle/oradata
      - ./init-user.sql:/docker-entrypoint-initdb.d/init-user.sql
    networks:
      - redis-cluster-network

# --------------------------
# Volumes
# --------------------------
volumes:
  oradata:
  mongodb_data:
  redis_stream_data:

# --------------------------
# Networks
# --------------------------
networks:
  redis-cluster-network:
    driver: bridge
