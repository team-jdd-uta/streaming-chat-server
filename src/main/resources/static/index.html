<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Spring Boot WebSocket Chat</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.5.0/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }
      #chat-container {
        width: 700px;
        border: 1px solid #ccc;
        padding: 12px;
      }
      #messages {
        height: 320px;
        overflow-y: scroll;
        border: 1px solid #eee;
        padding: 10px;
        margin-bottom: 10px;
      }
      #input-area input {
        width: 78%;
        padding: 8px;
      }
      #input-area button {
        width: 20%;
        padding: 8px;
      }
      #room-actions {
        margin-top: 8px;
        margin-bottom: 8px;
      }
      #room-actions input {
        width: 52%;
        padding: 6px;
      }
      #room-actions button {
        width: 22%;
        padding: 6px;
      }
      #roomSelector {
        width: 100%;
        padding: 6px;
      }
      .message {
        margin-bottom: 5px;
      }
      .system {
        color: gray;
        font-style: italic;
      }
      .mine {
        color: blue;
      }
      .other {
        color: green;
      }
      .muted {
        color: #666;
        font-size: 13px;
      }
    </style>
  </head>
  <body>
    <h1>Spring Boot WebSocket Chat</h1>

    <div id="connection-info">
      <label for="username">Username:</label>
      <input type="text" id="username" value="guest" /><br /><br />

      <label for="roomSelector">채팅방 선택:</label><br />
      <select id="roomSelector"></select>

      <div id="room-actions">
        <input type="text" id="newRoomName" placeholder="새 채팅방 이름" />
        <button onclick="createRoom()">방 만들기</button>
        <button onclick="refreshRooms()">목록 새로고침</button>
      </div>

      <button onclick="joinChat()">Join Chat</button>
      <button onclick="disconnect()">Leave Chat</button>
      <p id="statusText" class="muted">서버에서 채팅방 목록을 불러오는 중...</p>
    </div>

    <div id="chat-container">
      <div id="messages"></div>
      <div id="input-area">
        <input type="text" id="messageInput" placeholder="Type your message..." />
        <button onclick="sendMessage()">Send</button>
      </div>
    </div>

    <script>
      var stompClient = null;
      var username = null;
      var roomId = null;
      var reconnectScheduled = false;
      var reconnectTimer = null;
      var userInitiatedDisconnect = false;
      var reconnectBaseDelayMs = 1000;
      var reconnectMaxDelayMs = 10000;
      var reconnectJitterMaxMs = 300;
      var reconnectMaxDurationMs = 60000;
      var reconnectAttempt = 0;
      var reconnectStartedAtMs = null;

      var apiBases = ["http://localhost:8080", "http://localhost:8081"];
      var apiIndex = 0;
      var wsEndpoints = ["http://localhost:8080/ws/chat", "http://localhost:8081/ws/chat"];
      var endpointIndex = 0;

      function selectedApiBase() {
        return apiBases[apiIndex];
      }

      function moveToNextEndpoint() {
        endpointIndex = (endpointIndex + 1) % wsEndpoints.length;
        apiIndex = endpointIndex;
      }

      async function fetchWithFallback(path, options) {
        var attempts = 0;
        var lastError = null;
        while (attempts < apiBases.length) {
          var base = selectedApiBase();
          try {
            var response = await fetch(base + path, options || {});
            if (!response.ok) {
              throw new Error("HTTP " + response.status);
            }
            return response;
          } catch (error) {
            lastError = error;
            apiIndex = (apiIndex + 1) % apiBases.length;
            attempts += 1;
          }
        }
        throw lastError || new Error("All API servers failed");
      }

      function renderDisconnectedUI() {
        document.getElementById("connection-info").innerHTML = `
          <label for="username">Username:</label>
          <input type="text" id="username" value="guest"><br><br>
          <label for="roomSelector">채팅방 선택:</label><br>
          <select id="roomSelector"></select>
          <div id="room-actions">
            <input type="text" id="newRoomName" placeholder="새 채팅방 이름">
            <button onclick="createRoom()">방 만들기</button>
            <button onclick="refreshRooms()">목록 새로고침</button>
          </div>
          <button onclick="joinChat()">Join Chat</button>
          <button onclick="disconnect()">Leave Chat</button>
          <p id="statusText" class="muted">채팅방 목록을 불러오는 중...</p>
        `;
        refreshRooms();
      }

      function resetReconnectState() {
        reconnectScheduled = false;
        reconnectAttempt = 0;
        reconnectStartedAtMs = null;
        if (reconnectTimer !== null) {
          clearTimeout(reconnectTimer);
          reconnectTimer = null;
        }
      }

      function setStatus(text) {
        var statusText = document.getElementById("statusText");
        if (statusText) {
          statusText.textContent = text;
        }
      }

      function returnToMainScreen(reason) {
        console.warn("[WS] stop reconnecting:", reason);
        userInitiatedDisconnect = true;
        resetReconnectState();

        if (stompClient !== null) {
          try {
            stompClient.disconnect(function () {});
          } catch (e) {
            console.warn("Skip disconnect while socket is already closed", e);
          }
        }

        stompClient = null;
        username = null;
        roomId = null;
        document.getElementById("messages").innerHTML = "";
        renderDisconnectedUI();
        alert("서버 연결에 실패했습니다. 잠시 후 다시 시도해주세요.");
      }

      function scheduleReconnect(reason, delay) {
        if (userInitiatedDisconnect || reconnectScheduled) {
          return;
        }

        var now = Date.now();
        if (reconnectStartedAtMs === null) {
          reconnectStartedAtMs = now;
        }
        var elapsed = now - reconnectStartedAtMs;
        if (elapsed >= reconnectMaxDurationMs) {
          returnToMainScreen("reconnect timeout");
          return;
        }

        var backoffDelay = Math.min(
          reconnectBaseDelayMs * Math.pow(2, reconnectAttempt),
          reconnectMaxDelayMs,
        );
        var retryDelay = typeof delay === "number" ? delay : backoffDelay;
        retryDelay += Math.floor(Math.random() * reconnectJitterMaxMs);
        if (elapsed + retryDelay > reconnectMaxDurationMs) {
          retryDelay = reconnectMaxDurationMs - elapsed;
        }

        reconnectScheduled = true;
        console.log("[WS] reconnect scheduled:", reason, "after(ms):", retryDelay);
        setStatus("연결이 끊겨 재시도 중입니다...");

        reconnectTimer = setTimeout(function () {
          reconnectScheduled = false;
          reconnectAttempt += 1;
          moveToNextEndpoint();
          connect(true);
        }, retryDelay);
      }

      async function refreshRooms() {
        var selector = document.getElementById("roomSelector");
        if (!selector) {
          return;
        }
        setStatus("채팅방 목록을 불러오는 중...");
        try {
          var response = await fetchWithFallback("/chat/rooms");
          var rooms = await response.json();

          selector.innerHTML = "";
          if (!Array.isArray(rooms) || rooms.length === 0) {
            var emptyOption = document.createElement("option");
            emptyOption.value = "";
            emptyOption.textContent = "생성된 채팅방이 없습니다. 먼저 방을 만드세요.";
            selector.appendChild(emptyOption);
            setStatus("생성된 채팅방이 없습니다.");
            return;
          }

          rooms.forEach(function (room) {
            var option = document.createElement("option");
            option.value = room.roomId;
            option.textContent = room.name + " (" + room.roomId + ")";
            selector.appendChild(option);
          });
          setStatus("채팅방 " + rooms.length + "개를 불러왔습니다.");
        } catch (error) {
          console.error("Failed to load rooms", error);
          setStatus("채팅방 목록 조회 실패: 서버 상태를 확인하세요.");
        }
      }

      async function createRoom() {
        var input = document.getElementById("newRoomName");
        var name = input ? input.value.trim() : "";
        if (!name) {
          alert("방 이름을 입력하세요.");
          return;
        }

        try {
          var response = await fetchWithFallback("/chat/room?name=" + encodeURIComponent(name), {
            method: "POST",
          });
          var created = await response.json();
          if (input) {
            input.value = "";
          }
          await refreshRooms();

          var selector = document.getElementById("roomSelector");
          if (selector && created && created.roomId) {
            selector.value = created.roomId;
          }
          setStatus("채팅방이 생성되었습니다: " + created.name);
        } catch (error) {
          console.error("Failed to create room", error);
          alert("채팅방 생성에 실패했습니다.");
        }
      }

      function getSelectedRoomId() {
        var selector = document.getElementById("roomSelector");
        if (!selector) {
          return "";
        }
        return selector.value ? selector.value.trim() : "";
      }

      function connect(isReconnect) {
        if (!isReconnect) {
          var usernameInput = document.getElementById("username");
          username = usernameInput ? usernameInput.value.trim() : username;
          roomId = getSelectedRoomId();
        }

        if (!username) {
          alert("Username을 입력하세요.");
          return;
        }
        if (!roomId) {
          alert("채팅방을 선택하세요. (직접 ID 입력은 허용되지 않습니다)");
          return;
        }

        userInitiatedDisconnect = false;
        var endpoint = wsEndpoints[endpointIndex];
        console.log("[WS] connecting to:", endpoint);
        setStatus("채팅 서버에 연결 중...");

        var socket = new SockJS(endpoint);
        socket.onclose = function (event) {
          // 서버가 invalid payload(4002)로 끊은 경우 재시도하지 않고 화면 복귀
          if (event && (event.code === 4002 || String(event.reason || "").indexOf("Invalid payload") >= 0)) {
            returnToMainScreen("invalid payload");
            return;
          }
          scheduleReconnect("socket closed");
        };
        socket.onerror = function () {
          scheduleReconnect("socket error");
        };

        stompClient = Stomp.over(socket);

        stompClient.connect(
          {},
          function (frame) {
            console.log("Connected: " + frame);
            resetReconnectState();
            setStatus("연결됨");
            document.getElementById("connection-info").innerHTML = `
              <p>Connected as <strong>${username}</strong> to Room ID: <strong>${roomId}</strong></p>
              <button onclick="disconnect()">Leave Chat</button>
              <p class="muted">서버: ${wsEndpoints[endpointIndex]}</p>
            `;

            stompClient.subscribe("/sub/chat/room/" + roomId, function (messageOutput) {
              showMessageOutput(JSON.parse(messageOutput.body));
            });

            stompClient.subscribe("/sub/system/control", function (frameData) {
              var control = JSON.parse(frameData.body);
              if (control.type !== "RECONNECT" || reconnectScheduled) {
                return;
              }

              var base = control.retryAfterMs || 2000;
              var jitterMax = control.reconnectJitterMaxMs || 10000;
              var delay = base + Math.floor(Math.random() * jitterMax);
              console.log("[CONTROL] RECONNECT received:", control);
              scheduleReconnect("control reconnect", delay);

              if (stompClient && stompClient.connected) {
                stompClient.disconnect(function () {});
              }
            });

            stompClient.send(
              "/pub/chat/message",
              {},
              JSON.stringify({
                type: "ENTER",
                roomId: roomId,
                sender: username,
                message: "",
              }),
            );
          },
          function (error) {
            console.error("STOMP error", error);
            scheduleReconnect("stomp error");
          },
        );
      }

      function disconnect() {
        userInitiatedDisconnect = true;
        resetReconnectState();
        if (stompClient !== null) {
          try {
            stompClient.send(
              "/pub/chat/message",
              {},
              JSON.stringify({
                type: "QUIT",
                roomId: roomId,
                sender: username,
                message: "",
              }),
            );
          } catch (e) {
            console.warn("Skip QUIT send while disconnected", e);
          }
          stompClient.disconnect(function () {});
        }
        console.log("Disconnected");
        document.getElementById("messages").innerHTML = "";
        renderDisconnectedUI();
        stompClient = null;
        username = null;
        roomId = null;
      }

      function joinChat() {
        if (stompClient && stompClient.connected) {
          alert("이미 채팅에 접속해 있습니다. 먼저 Leave Chat 하세요.");
          return;
        }
        connect(false);
      }

      function sendMessage() {
        var messageInput = document.getElementById("messageInput");
        var messageContent = messageInput ? messageInput.value.trim() : "";
        if (!messageContent) {
          return;
        }
        if (!stompClient || !stompClient.connected) {
          alert("채팅 서버에 연결되어 있지 않습니다.");
          return;
        }

        var chatMessage = {
          type: "TALK",
          roomId: roomId,
          sender: username,
          message: messageContent,
        };
        stompClient.send("/pub/chat/message", {}, JSON.stringify(chatMessage));
        messageInput.value = "";
      }

      function showMessageOutput(messageOutput) {
        var messagesDiv = document.getElementById("messages");
        var p = document.createElement("p");
        p.classList.add("message");

        if (messageOutput.type === "ENTER" || messageOutput.type === "QUIT") {
          p.classList.add("system");
          p.appendChild(document.createTextNode(messageOutput.message));
        } else if (messageOutput.sender === username) {
          p.classList.add("mine");
          p.appendChild(document.createTextNode("(Me) " + messageOutput.message));
        } else {
          p.classList.add("other");
          p.appendChild(document.createTextNode("(" + messageOutput.sender + ") " + messageOutput.message));
        }

        messagesDiv.appendChild(p);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
      }

      document.getElementById("messageInput").addEventListener("keypress", function (e) {
        if (e.key === "Enter") {
          sendMessage();
        }
      });

      refreshRooms();
    </script>
  </body>
</html>
